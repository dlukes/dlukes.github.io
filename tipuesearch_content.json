{"pages":[{"tags":"pages","text":"I'm primarily a phonetician/linguist interested in programming and NLP applications, an avid fan of Linux and a beginning user of OS X. I like Python and Clojure and would like to learn me a Haskell for great good ; I find R useful (though convoluted on occasion) and avoid Perl as much as I can. I work at the Institute of the Czech National Corpus , so if you're interested in Czech and/or corpus linguistics , check us out! We have a nice and sleek web interface called KonText (with the manatee corpus query engine as a back-end) for all your Czech-related queries ;) I hail from Prague, Czech Republic, the most beautiful city in the world, and work and live there, though I've lived in France and Belgium for a while when I was a kid. I play badminton and football (of the soccer persuasion -- but it's still football) and enjoy American Jewish literature (to the point of writing my BA thesis on Philip Roth), as well as Jon Stewart, Ricky Gervais, Stephen Fry and several other smart people who can make me laugh. I used to play the saxophone reasonably well, but nowadays mostly enjoy playing the guitar atrociously bad and singing along. As you can tell from the title of this blog (if you're a fellow aficionado), I spent most of my teen years listening to the great music of one Frank Zappa . More about me on my homepage .","url":"http://dlukes.github.io/output/pages/about.html","title":"about me"},{"tags":"ling","text":"Or, the absolute minimum every software developer linguist absolutely, positively must know about Unicode and character sets (no excuses!) Note : This text was written as part of a larger programming tutorial in Python, and the code samples are taken from an interactive session using the Jupyter notebook . As a consequence, there are digressions here and there about playing with text data in Python. These might seem: useless if what you came for is just the part about text encoding; long-winded if you already know some Python; or confusing if, on the contrary, you're not familiar with programming at all, much less with Python. If any of these is your case, my advice is: ignore the code, focus on the comments around it, they're more than enough to follow the thread of the explanation. Though if you've got a little more time, why not try some of these out in an interactive Python session ? ;) And now, without further ado... Much like any other piece of data inside a digital computer, text is represented as a series of binary digits (bits), i.e. 0's and 1's. A mapping between sequences of bits and characters is called an encoding. How many different characters your encoding can handle depends on how many bits you allow per character: with 1 bit you can have 2&#94;1 = 2 characters (one is represented by 0, the other by 1) with 2 bits you can have 2&#94;2 = 4 characters(represented by 00, 01, 10 and 11) etc. The oldest encoding still in widespread use (it's what makes the Internet and the web tick) is ASCII , which is a 7-bit encoding: In [1]: 2 ** 7 Out[1]: 128 This means it can represent 128 different characters , which comfortably fits the basic Latin alphabet (both lowercase and uppercase), Arabic numerals, punctuation and some \"control characters\" which were primarily useful on the old teletype terminals for which ASCII was designed. For instance, the letter \"A\" corresponds to the number 65 ( 1000001 in binary, see below). \"ASCII\" stands for \" American Standard Code for Information Interchange\" -- which explains why there are no accented characters, for instance. Nowadays, ASCII is represented using 8 bits (== 1 byte), because that's the unit of computer memory which has become ubiquitous (in terms of both hardware and software assumptions), but still uses only 7 bits' worth of information. In [2]: 2 ** 8 Out[2]: 256 In [3]: # how to find out the binary representation of a decimal number? \"{:b}\" . format ( 65 ) Out[3]: &apos;1000001&apos; In [4]: # Digression/explanation: the format() method # # the format() string method inserts its arguments into the string # wherever there is a \"{}\" \"{} {} {}\" . format ( \"foo\" , \"bar\" , \"baz\" ) Out[4]: &apos;foo bar baz&apos; In [5]: # you can also specify a different order by using (zero-based) # positional indices -- or even repeating them \"{1} {0} {1}\" . format ( \"foo\" , \"bar\" ) Out[5]: &apos;bar foo bar&apos; In [6]: # for long strings with many insertions, where you might mess up the # order of arguments, keyword arguments are also available \"{foo_arg} {bar_arg}\" . format ( bar_arg = \"bar\" , foo_arg = \"foo\" ) Out[6]: &apos;foo bar&apos; In [7]: # and you can also request various formatting adjustments or conversions # to be made by specifying them after a \":\" -- e.g. \"b\" prints a given # number in its binary representation \"{:b}\" . format ( 45 ) Out[7]: &apos;101101&apos; In [8]: # or simply bin ( 45 ) # but that has an ugly \"0b\" in front, and we would've missed out on # format() if we'd used that directly! Out[8]: &apos;0b101101&apos; What happens in the range [128; 256) is not covered by the ASCII standard. In the 1990s, many encodings were standardized which used this range for their own purposes, usually representing additional accented characters used in a particular region. E.g. Czech (and Slovak, Polish...) alphabets can be represented using the ISO latin-2 encoding, or Microsoft's cp-1250 . Encodings which stick with the same character mappings as ASCII in the range [0; 128) and represent them physically in the same way (as 1 byte) , while potentially adding more character mappings beyond that, are called ASCII -compatible . ASCII compatibility is a good thingâ„¢, because when you start reading a character stream in a computer, there's no way to know in advance what encoding it is in (unless it's a file you've encoded yourself). So in practice, a heuristic has been established to start reading the stream assuming it is ASCII by default, and switch to a different encoding if evidence becomes available that motivates it. For instance, HTML files should all start something like this: <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> ... This way, whenever a program wants to read a file like this, it can start off with ASCII , waiting to see if it reaches the charset (i.e. encoding) attribute, and once it does, it can switch from ASCII to that encoding ( UTF-8 here) and restart reading the file, now fairly sure that it's using the correct encoding. This trick works only if we can assume that whatever encoding the rest of the file is in, the first few lines can be considered as ASCII for all practical intents and purposes. Without the charset attribute, the only way to know if the encoding is right would be for you to look at the rendered text and see if it makes sense; if it did not, you'd have to resort to trial and error, manually switching the encodings and looking for the one in which the numbers behind the characters stop coming out as gibberish and are actually translated into intelligible text. In [9]: # Let's take a look at printable characters in the latin-2 character # set. Each mapping is called a \"codepoint\": it is a correspondence # between an integer and a character. import codecs latin2 = [] for codepoint in range ( 256 ): byte = bytes ([ codepoint ]) character = codecs . decode ( byte , encoding = \"latin2\" ) if character . isprintable (): latin2 . append (( codepoint , character )) latin2 Out[9]: [(32, &apos; &apos;), (33, &apos;!&apos;), (34, &apos;\"&apos;), (35, &apos;#&apos;), (36, &apos;$&apos;), (37, &apos;%&apos;), (38, &apos;&&apos;), (39, \"&apos;\"), (40, &apos;(&apos;), (41, &apos;)&apos;), (42, &apos;*&apos;), (43, &apos;+&apos;), (44, &apos;,&apos;), (45, &apos;-&apos;), (46, &apos;.&apos;), (47, &apos;/&apos;), (48, &apos;0&apos;), (49, &apos;1&apos;), (50, &apos;2&apos;), (51, &apos;3&apos;), (52, &apos;4&apos;), (53, &apos;5&apos;), (54, &apos;6&apos;), (55, &apos;7&apos;), (56, &apos;8&apos;), (57, &apos;9&apos;), (58, &apos;:&apos;), (59, &apos;;&apos;), (60, &apos;<&apos;), (61, &apos;=&apos;), (62, &apos;>&apos;), (63, &apos;?&apos;), (64, &apos;@&apos;), (65, &apos;A&apos;), (66, &apos;B&apos;), (67, &apos;C&apos;), (68, &apos;D&apos;), (69, &apos;E&apos;), (70, &apos;F&apos;), (71, &apos;G&apos;), (72, &apos;H&apos;), (73, &apos;I&apos;), (74, &apos;J&apos;), (75, &apos;K&apos;), (76, &apos;L&apos;), (77, &apos;M&apos;), (78, &apos;N&apos;), (79, &apos;O&apos;), (80, &apos;P&apos;), (81, &apos;Q&apos;), (82, &apos;R&apos;), (83, &apos;S&apos;), (84, &apos;T&apos;), (85, &apos;U&apos;), (86, &apos;V&apos;), (87, &apos;W&apos;), (88, &apos;X&apos;), (89, &apos;Y&apos;), (90, &apos;Z&apos;), (91, &apos;[&apos;), (92, &apos;\\\\&apos;), (93, &apos;]&apos;), (94, &apos;&#94;&apos;), (95, &apos;_&apos;), (96, &apos;`&apos;), (97, &apos;a&apos;), (98, &apos;b&apos;), (99, &apos;c&apos;), (100, &apos;d&apos;), (101, &apos;e&apos;), (102, &apos;f&apos;), (103, &apos;g&apos;), (104, &apos;h&apos;), (105, &apos;i&apos;), (106, &apos;j&apos;), (107, &apos;k&apos;), (108, &apos;l&apos;), (109, &apos;m&apos;), (110, &apos;n&apos;), (111, &apos;o&apos;), (112, &apos;p&apos;), (113, &apos;q&apos;), (114, &apos;r&apos;), (115, &apos;s&apos;), (116, &apos;t&apos;), (117, &apos;u&apos;), (118, &apos;v&apos;), (119, &apos;w&apos;), (120, &apos;x&apos;), (121, &apos;y&apos;), (122, &apos;z&apos;), (123, &apos;{&apos;), (124, &apos;|&apos;), (125, &apos;}&apos;), (126, &apos;~&apos;), (161, &apos;Ä„&apos;), (162, &apos;Ë˜&apos;), (163, &apos;Å&apos;), (164, &apos;Â¤&apos;), (165, &apos;Ä½&apos;), (166, &apos;Åš&apos;), (167, &apos;Â§&apos;), (168, &apos;Â¨&apos;), (169, &apos;Å &apos;), (170, &apos;Åž&apos;), (171, &apos;Å¤&apos;), (172, &apos;Å¹&apos;), (174, &apos;Å½&apos;), (175, &apos;Å»&apos;), (176, &apos;Â°&apos;), (177, &apos;Ä…&apos;), (178, &apos;Ë›&apos;), (179, &apos;Å‚&apos;), (180, &apos;Â´&apos;), (181, &apos;Ä¾&apos;), (182, &apos;Å›&apos;), (183, &apos;Ë‡&apos;), (184, &apos;Â¸&apos;), (185, &apos;Å¡&apos;), (186, &apos;ÅŸ&apos;), (187, &apos;Å¥&apos;), (188, &apos;Åº&apos;), (189, &apos;Ë&apos;), (190, &apos;Å¾&apos;), (191, &apos;Å¼&apos;), (192, &apos;Å”&apos;), (193, &apos;Ã&apos;), (194, &apos;Ã‚&apos;), (195, &apos;Ä‚&apos;), (196, &apos;Ã„&apos;), (197, &apos;Ä¹&apos;), (198, &apos;Ä†&apos;), (199, &apos;Ã‡&apos;), (200, &apos;ÄŒ&apos;), (201, &apos;Ã‰&apos;), (202, &apos;Ä˜&apos;), (203, &apos;Ã‹&apos;), (204, &apos;Äš&apos;), (205, &apos;Ã&apos;), (206, &apos;ÃŽ&apos;), (207, &apos;ÄŽ&apos;), (208, &apos;Ä&apos;), (209, &apos;Åƒ&apos;), (210, &apos;Å‡&apos;), (211, &apos;Ã“&apos;), (212, &apos;Ã”&apos;), (213, &apos;Å&apos;), (214, &apos;Ã–&apos;), (215, &apos;Ã—&apos;), (216, &apos;Å˜&apos;), (217, &apos;Å®&apos;), (218, &apos;Ãš&apos;), (219, &apos;Å°&apos;), (220, &apos;Ãœ&apos;), (221, &apos;Ã&apos;), (222, &apos;Å¢&apos;), (223, &apos;ÃŸ&apos;), (224, &apos;Å•&apos;), (225, &apos;Ã¡&apos;), (226, &apos;Ã¢&apos;), (227, &apos;Äƒ&apos;), (228, &apos;Ã¤&apos;), (229, &apos;Äº&apos;), (230, &apos;Ä‡&apos;), (231, &apos;Ã§&apos;), (232, &apos;Ä&apos;), (233, &apos;Ã©&apos;), (234, &apos;Ä™&apos;), (235, &apos;Ã«&apos;), (236, &apos;Ä›&apos;), (237, &apos;Ã­&apos;), (238, &apos;Ã®&apos;), (239, &apos;Ä&apos;), (240, &apos;Ä‘&apos;), (241, &apos;Å„&apos;), (242, &apos;Åˆ&apos;), (243, &apos;Ã³&apos;), (244, &apos;Ã´&apos;), (245, &apos;Å‘&apos;), (246, &apos;Ã¶&apos;), (247, &apos;Ã·&apos;), (248, &apos;Å™&apos;), (249, &apos;Å¯&apos;), (250, &apos;Ãº&apos;), (251, &apos;Å±&apos;), (252, &apos;Ã¼&apos;), (253, &apos;Ã½&apos;), (254, &apos;Å£&apos;), (255, &apos;Ë™&apos;)] Using the 8th bit (and thus the codepoint range [128; 256)) solves the problem of handling languages with character sets different than that of American English, but introduces a lot of complexity -- whenever you come across a text file with an unknown encoding, it might be in one of literally dozens of encodings. Additional drawbacks include: how to handle multilingual text with characters from many different alphabets, which are not part of the same 8-bit encoding? how to handle writing systems which have way more than 256 \"characters\", e.g. Chinese, Japanese and Korean (CJK) ideograms? For these purposes, a standard encoding known as Unicode was developed which strives for universal coverage of all possible character sets. Unicode is much bigger than the encodings we've seen so far -- its most frequently used subset, the Basic Multilingual Plane , has 2&#94;16 codepoints, but overall the number of codepoints is past 1M and there's room to accommodate many more. In [10]: 2 ** 16 Out[10]: 65536 Now, the most straightforward representation for 2&#94;16 codepoints is what? Well, it's simply using 16 bits per character, i.e. 2 bytes. That encoding exists, it's called UTF-16 , but consider the drawbacks: we've lost ASCII compatibility by the simple fact of using 2 bytes per character instead of 1 (encoding \"a\" as 01100001 or 01100001|00000000 , with the | indicating an imaginary boundary between bytes, is not the same thing) encoding a string in a character set which uses a \"reasonable\" number of characters (like any European language) now takes twice as much space without any added benefit (which is probably not a good idea, given the general dominance of English -- one of those \"reasonable character set size\" languages -- in electronic communication) Looks like we'll have to think outside the box. The box in question here is called fixed-width encodings -- all of the encoding schemes we've encountered so far were fixed-width, meaning that each character was represented by either 7, 8 or 16 bits. In other word, you could jump around the string in multiples of 7, 8 or 16 and always land at the beginning of a character. (Not exactly true for UTF-16 , because it is something more than just a \"16-bit ASCII \": it has ways of handling characters beyond 2&#94;16 using so-called surrogate sequences -- but you get the gist.) \"UTF\" stands for \"Unicode Transformation Format\". The smart idea that some bright people have come up with was to use a variable-width encoding . The most ubiquitous one currently is UTF-8 , which we've already met in the HTML example above. UTF-8 is ASCII -compatible, i.e. the 1's and 0's used to encode text containing only ASCII characters are the same regardless of whether you use ASCII or UTF-8 : it's a sequence of 8-bit bytes. But UTF-8 can also handle many more additional characters, as defined by the Unicode standard, by using progressively longer and longer sequences of bits. In [11]: def print_as_binary_utf8 ( string ): \"\"\"Prints binary representation of string as encoded by UTF-8. \"\"\" # encode the string as UTF-8 byte = string . encode ( \"utf-8\" ) # get the hexadecimal representation of the bytes hexa = byte . hex () # convert the hexadecimal representation to a decimal integer inte = int ( hexa , base = 16 ) # create a string containing the integer, formatted as binary binary_str = \"'{}' encoded in UTF-8 is: {:b}\" . format ( string , inte ) # print that binary representation. whew! if there's an easier # way (e.g. at least skipping the intermediate hexadecimal # representation), please let me know! print ( binary_str ) print_as_binary_utf8 ( \"A\" ) # the representations... print_as_binary_utf8 ( \"Ä\" ) # ... keep... print_as_binary_utf8 ( \"å­—\" ) # ... getting longer. &apos;A&apos; encoded in UTF-8 is: 1000001 &apos;Ä&apos; encoded in UTF-8 is: 1100010010001101 &apos;å­—&apos; encoded in UTF-8 is: 111001011010110110010111 How does it achieve that? The obvious problem here is that with a fixed-width encoding, you just chop up the string at regular intervals (7, 8, 16 bits) and you know that each interval represents one character. So how do you know where to chop up a variable width-encoded string, if each character can take up a different number of bits? We won't go into the details, but essentially, the trick is to use some of the bits in the representation of a codepoint to store information not about which character it is (whether it's an \"A\" or a \"å­—\"), but how many bits it occupies . In other words, if you want to skip ahead 10 characters in a string encoded with a variable width-encoding, you can't just skip 10 * 7 or 8 or 16 bits; you have to read all the intervening characters to figure out how much space they take up. There's much more to Unicode than this simple introduction, for instance the various ways diacritics are handled: \"Ä\" can be represented either as a single codepoint ( LATIN SMALL LETTER C WITH CARON -- all Unicode codepoints have cute names like this) or a sequence of two codepoints, the character \"c\" and a combining diacritic mark ( COMBINING CARON ). You can search for the codepoints corresponding to Unicode characters e.g. here and play with them in Python using the chr(0xXXXX) built-in function or with the special string escape sequence \\uXXXX (where XXXX is the hexadecimal representation of the codepoint) -- both are ways to get the character corresponding to the given codepoint: In [12]: # \"Ä\" as LATIN SMALL LETTER C WITH CARON, codepoint 010D print ( chr ( 0x010D )) print ( \" \\u010D \" ) Ä Ä In [13]: # \"Ä\" as a sequence of LATIN SMALL LETTER C, codepoint 0063, and # COMBINING CARON, codepoint 030c print ( chr ( 0x0063 ) + chr ( 0x030c )) print ( \" \\u0063\\u030c \" ) cÌŒ cÌŒ Hexadecimal is just a more convenient way of representing sequences of bits, where each of the X 's can be a number between 0 and 15 (10--15 are represented by the letters A--F). Each hexadecimal number can thus represent 16 different values, and therefore it can stand in for a sequence of 4 bits (2&#94;4 == 16). Without worrying too much about the details right now, our old friend ASCII uppercase \"A\" can be thought of equivalently either as decimal 65, binary 1000001 , or hexadecimal 0x41 (the \"0x\" prefix is there just to say \"this is a hexadecimal number\"). > Binary and hexadecimal numbers are often written padded with leading zeros to some number of bytes, but these have no effect on the value, much like decimal 42 and 00000042 are effectively the same numbers. In [14]: # use hex() to find out the hexadecimal representation of a decimal # integer... hex ( 99 ) Out[14]: &apos;0x63&apos; In [15]: # ... and int() to go back int ( 0x63 ) Out[15]: 99 This means you have to be careful when working with languages that use accents, because for a computer, the two possible representations are of course different strings , even though for you, they're conceptually the same: In [16]: s1 = \" \\u010D \" s2 = \" \\u0063\\u030c \" # s1 and s2 look the same to the naked eye... print ( s1 , s2 ) Ä cÌŒ In [17]: # ... but in the eternal realm of Plato's Ideas, they're not s1 == s2 Out[17]: False Watch out, they even have different lengths ! This might come to bite you if you're trying to compute the length of a word in letters. In [18]: print ( \"s1 is\" , len ( s1 ), \"character(s) long.\" ) print ( \"s2 is\" , len ( s2 ), \"character(s) long.\" ) s1 is 1 character(s) long. s2 is 2 character(s) long. Generally, most text out there will use the first, single-codepoint approach whenever possible, and pre-packaged linguistic corpora will try to be consistent about this (unless they come from the web, which always warrants being suspicious and defensive about your material). If you're worried about inconsistencies in your data, you can perform a normalization : In [19]: from unicodedata import normalize # NFC stands for Normal Form C; this normalization applies a canonical # decomposition (into a multi-codepoint representation) followed by a # canonical composition (into a single-codepoint representation) s1 = normalize ( \"NFC\" , s1 ) s2 = normalize ( \"NFC\" , s2 ) s1 == s2 Out[19]: True Let's wrap things up by saying that Python itself uses Unicode internally and (mostly?) assumes UTF-8 when reading files. So if you're using UTF-8 as is increasingly the case (and you should be), you won't have to worry too much about encodings, except perhaps for normalization. In [20]: # a good idea when dealing with Unicode text from an unknown and # unreliable source is to look at the set of codepoints contained # in it and eliminate or replace those that shouldn't be there import unicodedata def inspect_codepoints ( text ): charset = set () for char in text : charset . add ( char ) for char in sorted ( charset ): info = r\"{} (\\u{:04x}): {} (category: {})\" . format ( char , ord ( char ), unicodedata . name ( char ), unicodedata . category ( char )) print ( info ) # depending on your font configuration, it may be very hard to spot # the two intruders in the sentence below that look like regular # letters but really are specialized variants; you might want # to replace them before doing further text processing... inspect_codepoints ( \"Intruders here, good ð—hinÉ¡ I checked.\" ) (\\u0020): SPACE (category: Zs) , (\\u002c): COMMA (category: Po) . (\\u002e): FULL STOP (category: Po) I (\\u0049): LATIN CAPITAL LETTER I (category: Lu) c (\\u0063): LATIN SMALL LETTER C (category: Ll) d (\\u0064): LATIN SMALL LETTER D (category: Ll) e (\\u0065): LATIN SMALL LETTER E (category: Ll) g (\\u0067): LATIN SMALL LETTER G (category: Ll) h (\\u0068): LATIN SMALL LETTER H (category: Ll) i (\\u0069): LATIN SMALL LETTER I (category: Ll) k (\\u006b): LATIN SMALL LETTER K (category: Ll) n (\\u006e): LATIN SMALL LETTER N (category: Ll) o (\\u006f): LATIN SMALL LETTER O (category: Ll) r (\\u0072): LATIN SMALL LETTER R (category: Ll) s (\\u0073): LATIN SMALL LETTER S (category: Ll) t (\\u0074): LATIN SMALL LETTER T (category: Ll) u (\\u0075): LATIN SMALL LETTER U (category: Ll) É¡ (\\u0261): LATIN SMALL LETTER SCRIPT G (category: Ll) ð— (\\u1d5cd): MATHEMATICAL SANS-SERIF SMALL T (category: Ll) In [21]: # ... because of course, for a computer, the word \"thing\" written with # two different variants of \"g\" is really just two different words, which # is probably not what you want \"thing\" == \"thinÉ¡\" Out[21]: False In any case, here's what happens when processing text with Python (\"Unicode\" in the central box stands for Python's internal representation of Unicode, which is not UTF-8 nor UTF-16 ): (Image shamelessly hotlinked from / courtesy of the NLTK Book . Go check it out, it's an awesome intro to Python programming for linguists!) A terminological postscript: we've been using some terms a bit informally and for the most part it's okay, but it's good to get the distinctions straight in one's head at least once. So, a character set is a mapping between codepoints (integers) and characters . We may for instance say that in our character set, the integer 99 corresponds to the character \"c\". On the other hand, an encoding is a mapping between a codepoint (an integer) and a physical sequence of 1's and 0's that represent it in memory . With fixed-width encodings, this mapping is generally straightforward -- the 1's and 0's directly represent the given integer, only in binary and padded with zeros to fit the desired width. With variable-width encodings, as the necessity creeps in to include the information about how many bits are spanned by the current character, this straightforward correspondence breaks down. A comparison might be helpful here: as encodings, UTF-8 and UTF-16 both use the same character set -- the same integers corresponding to the same characters. But since they're different encodings , when the time comes to turn these integers into sequences of bits to store in a computer's memory, each of them generates a different one. For more on Unicode, a great read already hinted at above is Joel Spolsky's The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) . To make the discussion digestible for newcomers, I sometimes slightly distorted facts about how things are \"really really\" done. And some inaccuracies may be genuine mistakes. In any case, please let me know in the comments! I'm grateful for feedback and looking to improve this material; I'll fix the mistakes and consider ditching some of the simplifications if they prove untenable :)","url":"http://dlukes.github.io/output/unicode.html","title":"How computers handle text: a gentle but thorough introduction to Unicode"},{"tags":"ling","text":"PÅ™ed nÄ›jakou dobou jsem zde vyvÄ›sil skript , jehoÅ¾ pomocÃ­ lze lehce \"pÅ™esklÃ¡dat\" a upravit rozhranÃ­ korpusovÃ©ho konkordanceru KonText : menu je umÃ­stÄ›nÃ© po stranÄ› mÃ­sto nahoÅ™e a permanentnÄ› rozbalenÃ© nad vyhledanou konkordancÃ­ je umÃ­stÄ›n rychlÃ½ hledacÃ­ box, v nÄ›mÅ¾ lze pÅ™edchozÃ­ dotaz pohodlnÄ› upravit VÃ­c o motivaci tÄ›chto Ãºprav se doÄtete v pÅ¯vodnÃ­m ÄlÃ¡nku . StÃ¡le platÃ­, Å¾e ÄŒNK nemÃ¡ v plÃ¡nu tyto zmÄ›ny zaÄlenit pÅ™Ã­mo do oficiÃ¡lnÃ­ verze KonTextu, zejmÃ©na proto, Å¾e rychlÃ½ hledacÃ­ box sice v jistÃ½ch situacÃ­ch mÅ¯Å¾e bÃ½t uÅ¾iteÄnÃ½, nicmÃ©nÄ› oproti standardnÃ­mu formulÃ¡Å™i NovÃ½ dotaz vÃ½raznÄ› omezuje moÅ¾nosti pro zadÃ¡nÃ­ dotazu. VylepÅ¡enÃ¡ verze, kterÃ¡ je k dispozici nÃ­Å¾e, odstraÅˆuje nÄ›kterÃ© pÅ™edchozÃ­ nedostatky skriptu: rychlÃ½ hledacÃ­ box nad konkordancÃ­ je vÄ›tÅ¡Ã­, ukazuje vÅ¾dy CQL podobu poslednÃ­ho zadanÃ©ho dotazu 1 , a pÅ™edevÅ¡Ã­m zÅ¯stÃ¡vÃ¡ zobrazenÃ½ i bÄ›hem listovÃ¡nÃ­ konkordancÃ­ (tj. nenÃ­ k dispozici jen na jejÃ­ prvnÃ­ strÃ¡nce). Dotaz lze nynÃ­ navÃ­c pro vÄ›tÅ¡Ã­ pÅ™ehlednost rozdÄ›lit do vÃ­ce Å™Ã¡dkÅ¯, takÅ¾e opÄ›tovnÃ© vyhledÃ¡vÃ¡nÃ­ se novÄ› spouÅ¡tÃ­ stiskem kombinace klÃ¡ves Ctrl+Enter (mÃ­sto jen Enteru). VÃ½slednÃ© upravenÃ© rozhranÃ­ KonText vypadÃ¡ stÃ¡le podobnÄ›: Postup instalace skriptu NovÃ¡ verze skriptu je k dispozici zde: Kroky k jeho zprovoznÄ›nÃ­ zÅ¯stÃ¡vajÃ­ stejnÃ©: Nainstalovat si do svÃ©ho prohlÃ­Å¾eÄe plugin Tampermonkey , pokud pouÅ¾Ã­vÃ¡te Chrome, nebo Greasemonkey , pokud pouÅ¾Ã­vÃ¡te Firefox. (Pokud pouÅ¾Ã­vÃ¡te Internet Explorer, budete muset doÄasnÄ› pÅ™esedlat na Chrome nebo Firefox.) TestovanÃ½ je skript zatÃ­m jen na Chromu. ZaloÅ¾it v danÃ©m pluginu novÃ½ skript (pro Chrome je tutorial zde , pro Firefox zde ). Smazat kostru novÃ©ho skriptu a nahradit ji skriptem, kterÃ½ si zkopÃ­rujete vÃ½Å¡e. Skript uloÅ¾it. PouÅ¾Ã­vat KonText jako normÃ¡lnÄ› -- skript uÅ¾ by podle adresy mÄ›l sÃ¡m poznat, Å¾e se mÃ¡ spustit. Pokud se tak nestane, nejspÃ­Å¡ to znamenÃ¡, Å¾e je prohlÃ­Å¾eÄovÃ½ plugin (Tampermonkey nebo Greasemonkey) deaktivovanÃ½ a je potÅ™eba jej znovu aktivovat. V pÅ™edchozÃ­ verzi se po aplikaci libovolnÃ©ho filtru zmÄ›nil obsah hledacÃ­ho boxu na parametry filtrovÃ¡nÃ­. â†©","url":"http://dlukes.github.io/output/kontext-interface-tweak-update.html","title":"Ãšprava rozhranÃ­ konkordanceru KonText -- vylepÅ¡enÃ¡ verze"},{"tags":"ling","text":"!POZOR! K dispozici je nynÃ­ vylepÅ¡enÃ¡ verze nÃ­Å¾e popsanÃ©ho skriptu . HledÃ¡nÃ­ v korpusech ÄŒNK ÄŒeskÃ½ nÃ¡rodnÃ­ korpus je sbÃ­rka jazykovÃ½ch korpusÅ¯ ÄÃ¡steÄnÄ› vytvÃ¡Å™enÃ½ch Ãšstavem ÄŒeskÃ©ho nÃ¡rodnÃ­ho korpusu a ÄÃ¡steÄnÄ› jinÃ½mi institucemi. VÅ¡echny jsou hostovanÃ© na jednom serveru a dostupnÃ© skrz rÅ¯znÃ¡ vyhledÃ¡vacÃ­ rozhranÃ­ (tzv. konkordancery ), napÅ™. NoSke , Bonito Äi nejnovÄ›ji KonText . Koncem bÅ™ezna 2015 ovÅ¡em bude podpora starÅ¡Ã­ch rozhranÃ­ ukonÄena a nadÃ¡le pÅ¯jde k datÅ¯m v ÄŒNK pÅ™istupovat primÃ¡rnÄ› pouze pÅ™es KonText. (Pokud vÃ¡m odstavec vÃ½Å¡e nedÃ¡vÃ¡ pÅ™Ã­liÅ¡ smysl, s jazykovÃ½mi korpusy se setkÃ¡vÃ¡te poprvÃ©, ale chcete se dozvÄ›dÄ›t vÃ­c, radÄ›ji si mÃ­sto tohoto postu pÅ™eÄtÄ›te, k Äemu je takovÃ½ korpus dobrÃ½ , a zkuste si v nÄ›m nÄ›co pro zajÃ­mavost vyhledat . Pokud se vÃ¡m pÅ™i vzpomÃ­nce na Bonito Äi NoSke naopak zaskvÄ›la slza v oku, ÄtÄ›te dÃ¡l!) KonText vs. Bonito / NoSke KonText mÃ¡ oproti starÅ¡Ã­m rozhranÃ­m Å™adu vÃ½hod -- bohatÅ¡Ã­ funkcionalitu, mnohÃ© pomÅ¯cky, kterÃ© vÃ¡m pomohou se zadÃ¡nÃ­m sloÅ¾itÄ›jÅ¡Ã­ch dotazÅ¯ (sestavenÃ­ morfologickÃ©ho tagu Äi podmÃ­nky within ), a v neposlednÃ­ Å™adÄ› mnohem lÃ©pe vypadÃ¡, coÅ¾ kupÅ™Ã­kladu mnÄ› pÅ™i prÃ¡ci pÅ¯sobÃ­ jako balzÃ¡m na duÅ¡i. NicmÃ©nÄ› dlouholetÃ­ uÅ¾ivatelÃ© ÄŒNK byli jednoduÅ¡e zvyklÃ­ na nÄ›kterÃ© aspekty Bonita a NoSke, kterÃ© jim teÄ v KonTextu chybÃ­. Onehdy pÅ™i rozhovoru s jednÃ­m z nich vyplavaly na povrch jako hodnÄ› dÅ¯leÅ¾itÃ© dvÄ› stÃ­Å¾nosti: VrchnÃ­ menu v KonTextu je zÃ¡keÅ™nÃ©, schovÃ¡vÃ¡ se, ÄlovÄ›k nemÃ¡ pÅ™ehled nad dostupnÃ½mi funkcemi. Oproti tomu NoSke mÃ¡ menu po stranÄ› a je permanentnÄ› rozvinutÃ©, takÅ¾e uÅ¾ivatel mÃ¡ vÅ¡echny moÅ¾nosti interakce s konkordancÃ­ soustavnÄ› jako na dlani. Po zadÃ¡nÃ­ dotazu ÄlovÄ›k Äasto na zÃ¡kladÄ› konkordance zjistÃ­, Å¾e jej potÅ™ebuje jeÅ¡tÄ› trochu upravit / zjemnit. KonText si sice pÅ™edchozÃ­ dotazy pamatuje, je ale potÅ™eba se k nim doklikat; Å¡ikovnÄ›jÅ¡Ã­ by bylo, kdyby tato moÅ¾nost byla dostupnÃ¡ pÅ™Ã­mo ze strÃ¡nky konkordance v podobÄ› nÄ›jakÃ©ho zjednoduÅ¡enÃ©ho hledacÃ­ho boxu. (NoSke tohle vlastnÄ› taky neumÃ­, v Bonitu je to jednoduÅ¡Å¡Ã­.) V obou pÅ™Ã­padech jde o smysluplnÃ© poÅ¾adavky, jenÅ¾e KonText je pomÄ›rnÄ› velkÃ¡ a sloÅ¾itÃ¡ aplikace, takÅ¾e i pokud se ÄŒNK rozhodne do nÃ­ tyto podnÄ›ty v nÄ›jakÃ© podobÄ› zapracovat (napÅ™. jako moÅ¾nost pÅ™epnutÃ­ zobrazenÃ­ menu), bude nÄ›jakou chvÃ­li trvat, neÅ¾ se implementace navrhne, vytvoÅ™Ã­, Å™Ã¡dnÄ› otestuje a koneÄnÄ› dostane k uÅ¾ivatelÅ¯m. NicmÃ©nÄ› aby bylo moÅ¾nÃ© alespoÅˆ vyzkouÅ¡et, jak by zmÃ­nÄ›nÃ© zmÄ›ny vypadaly v praxi, dal jsem dohromady krÃ¡tkÃ½ skript, kterÃ½ jiÅ¾ v prohlÃ­Å¾eÄi nahranÃ½ KonText trochu \"pÅ™estavÃ­\" a upravÃ­. VÃ½sledek vypadÃ¡ nÃ¡sledovnÄ›: Rovnou pÅ™edesÃ­lÃ¡m: ten skript je nevzhlednÃ½ bastl pÅ™ilepenÃ½ na KonText zvnÄ›jÅ¡ku; proto taky bylo moÅ¾nÃ© jej dÃ¡t dohromady pomÄ›rnÄ› rychle, protoÅ¾e si neklade nÃ¡rok na spolehlivost, kterÃ¡ se vyÅ¾aduje od oficiÃ¡lnÃ­ verze KonTextu. Je to spÃ­Å¡ prototyp, jehoÅ¾ ÃºÄelem je otestovat vÃ½Å¡e popsanÃ© zmÄ›ny v praxi a zÃ­skat pÅ™edstavu o tom, zda a do jakÃ© mÃ­ry jsou pÅ™Ã­nosnÃ©. (VlastnÃ­ zkuÅ¡enost: po chvÃ­li pouÅ¾Ã­vÃ¡nÃ­ mi pÅ™ijde pÅ™Ã­datnÃ½ hledacÃ­ box nad konkordancÃ­ hodnÄ› Å¡ikovnÃ½ a uÅ¾iteÄnÃ½.) TeÄ k jÃ¡dru pudla: pokud mÃ¡te zÃ¡jem, mÅ¯Å¾ete si KonText takto k obrazu svÃ©mu (resp. k obrÃ¡zku o odstavec vÃ½Å¡) upravit takÃ© a vyzkouÅ¡et, jak vÃ¡m takovÃ© nastavenÃ­ vyhovuje. KdyÅ¾ se vÃ¡m jedna z Ãºprav bude lÃ­bit (nebo vÃ¡s u toho napadne jinÃ¡, kterou by si KonText zaslouÅ¾il), mÅ¯Å¾ete pak zadat poÅ¾adavek na novÃ½ feature . NÃ¡vod, jak si KonText upravit, nÃ¡sleduje nÃ­Å¾e. Postup instalace skriptu Skript samotnÃ½ je k dispozici zde: K jeho zprovoznÄ›nÃ­ jsou potÅ™eba nÃ¡sledujÃ­cÃ­ kroky: Nainstalovat si do svÃ©ho prohlÃ­Å¾eÄe plugin Tampermonkey , pokud pouÅ¾Ã­vÃ¡te Chrome, nebo Greasemonkey , pokud pouÅ¾Ã­vÃ¡te Firefox. (Pokud pouÅ¾Ã­vÃ¡te Internet Explorer, budete muset doÄasnÄ› pÅ™esedlat na Chrome nebo Firefox.) TestovanÃ½ je skript zatÃ­m jen na Chromu. ZaloÅ¾it v danÃ©m pluginu novÃ½ skript (pro Chrome je tutorial zde , pro Firefox zde ). Smazat kostru novÃ©ho skriptu a nahradit ji skriptem, kterÃ½ si zkopÃ­rujete vÃ½Å¡e. Skript uloÅ¾it. PouÅ¾Ã­vat KonText jako normÃ¡lnÄ› -- skript uÅ¾ by podle adresy mÄ›l sÃ¡m poznat, Å¾e se mÃ¡ spustit. Pokud se tak nestane, nejspÃ­Å¡ to znamenÃ¡, Å¾e je prohlÃ­Å¾eÄovÃ½ plugin (Tampermonkey nebo Greasemonkey) deaktivovanÃ½ a je potÅ™eba jej znovu aktivovat. OmezenÃ­ Skript mÃ¡ pravdÄ›podobnÄ› hromadu drobnÃ½ch much, na kterÃ© se mi zatÃ­m nepodaÅ™ilo pÅ™ijÃ­t -- budu se je snaÅ¾it prÅ¯bÄ›Å¾nÄ› opravovat, kdyÅ¾ na nÄ› padnu, nebo kdyÅ¾ mi o nich dÃ¡te vÄ›dÄ›t . Krom toho mÃ¡ i nÄ›kterÃ© mouchy, o nichÅ¾ uÅ¾ vÃ­m, ale bohuÅ¾el toho s nimi nejde moc dÄ›lat. Asi nejnÃ¡padnÄ›jÅ¡Ã­ je, Å¾e pÅ™idanÃ½ hledacÃ­ box funguje jen na tÄ›ch strÃ¡nkÃ¡ch, kde je pÅ¯vodnÃ­ dotaz i souÄÃ¡stÃ­ adresy URL (coÅ¾ nejsou vÅ¡echny -- tÅ™eba kdyÅ¾ zaÄnete listovat konkordancÃ­ na druhou strÃ¡nku a dÃ¡l, dotaz je z adresy vyjmut a pomocnÃ½ hledacÃ­ box tedy zmizÃ­ ). Ale vzhledem k tomu, Å¾e jeho hlavnÃ­ ÃºÄel mÃ¡ bÃ½t moÅ¾nost lehce upravit dotaz po prvnÃ­m rychlÃ©m nahlÃ©dnutÃ­ do konkordance, snad to nebude takovÃ½ problÃ©m. Pokud nÄ›kdy bude podobnÃ½ box Å™Ã¡dnÄ› pÅ™idÃ¡n pÅ™Ã­mo do KonTextu, takovÃ½mi nedostatky samozÅ™ejmÄ› trpÄ›t nebude. A jeÅ¡tÄ› k pouÅ¾Ã­vÃ¡nÃ­ pÅ™idanÃ©ho hledacÃ­ho boxu : Typ dotazu, kterÃ½ je do nÄ›j potÅ™eba zadat, je stejnÃ½ jako ten, kterÃ½ jste pÅ™i prvotnÃ­m vyhledÃ¡nÃ­ konkordance zadali na strÃ¡nce NovÃ½ dotaz . Pokud tento prvotnÃ­ dotaz byl ZÃ¡kladnÃ­ dotaz, mÅ¯Å¾ete pomocÃ­ rychlÃ©ho boxu zadat jinÃ½ ZÃ¡kladnÃ­ dotaz; pokud to byl CQL dotaz, mÅ¯Å¾ete ho upravit zas jen na dalÅ¡Ã­ CQL dotaz. DÅ¯vodem je, Å¾e smyslem tohoto pomocnÃ©ho boxu nenÃ­ nahradit plnohodnotnÃ½ formulÃ¡Å™ pro zadÃ¡nÃ­ dotazu, jen poskytnout rychlou moÅ¾nost, jak jiÅ¾ zadanÃ½ dotaz upravit . PomocnÃ½ hledacÃ­ box se objevÃ­ i potÃ©, co na konkordanci provedete filtrovÃ¡nÃ­. V takovÃ© situaci se dÃ¡ pouÅ¾Ã­t k tomu, abyste pozmÄ›nili zadÃ¡nÃ­ aktuÃ¡lnÃ­ho filtru , tj. filtrovÃ¡nÃ­ se provede znovu na pÅ¯vodnÃ­ konkordanci, ne na tÃ©to jiÅ¾ filtrovanÃ©. Pokud chcete opakovanÄ› filtrovat tu samou konkordanci a postupnÄ› podle danÃ½ch kritÃ©riÃ­ vyÅ™azovat / pÅ™idÃ¡vat Å™Ã¡dky, je potÅ™eba mÃ­sto hledacÃ­ho boxu opakovanÄ› pouÅ¾Ã­t menu Filtr . Komu si stÄ›Å¾ovat, kdyÅ¾ to nebude fungovat Skript je volnÄ› Å¡iÅ™itelnÃ½ pod licencÃ­ GNU GPL v3 , takÅ¾e se na nÄ›j nevÃ¡Å¾e Å¾Ã¡dnÃ¡ zÃ¡ruka. KdyÅ¾ se vÃ¡m ale nebude daÅ™it jej zprovoznit, rÃ¡d se pokusÃ­m pomoct! StaÄÃ­ se ozvat na adresu uvedenou zde .","url":"http://dlukes.github.io/output/kontext-interface-tweak.html","title":"Ãšprava rozhranÃ­ konkordanceru KonText"},{"tags":"floss","text":"Background Ever since I first read about semantic versioning , I've thought of it as a neat idea. But only recently did it occur to me that what I liked about the idea was its goal, much less its execution (more on that below). What made it obvious was this lengthy discussion about breaking changes introduced in v1.7 of underscore.js without an accompanying major version bump. Even though I still think sticking to semver is the right thing to do if your community of users expects you to (even if you don't personally like the system), I am convinced there are fundamentally better ways of dealing with the problem of safely and consistently updating dependencies. It made me want to add my two cents to the discussion , as someone who's more of a dabbler in programming and not really part of the community, so feel free to ignore me :) I attach my commentary below for reference (it's virtually the same text as in the link above). tl;dr semver is trying to do the right thing, but doing it wrong -- instead of implicitly encoding severity of change information in version numbers , explicit keywords like :patch, :potentially-breaking or :major-api-change would make much more sense. More verbosely I've always found the goals of semver worthy, but this thread has made me realize that while its aims are commendable, its methods are kind of broken: semver tries to take an existing semiotic system (= version numbers), which has developed informally and is therefore a loose convention rather than an exact spec, and reinterpret it in terms of an exact spec (or impose that spec on it). trouble is, the prior informal meaning won't go away so easily (why should it?), especially for projects that have been around longer than semver. the problem then is, since the two systems (the informal one and semver) look the same in terms of their symbolic representation, it's hard to guess which one you're dealing with by just eyeballing the version number of a library (or project in general). it's like if someone decided that \"f*ck\" should mean \"orchid\" from now on, because it's nicer -- on hearing the word, you'd never know if it's being used as the original profanity, or in its new meaning. homonymy is a pain to deal with when it's accidental (cf. NLP), so why introduce it on purpose? the job that semver set out to do should be fulfilled by a new formal means which is instantly recognizable, not by hijacking an existing one and overlaying additional interpretation on it and thus making it ambiguous . even if version numbers hadn't existed before semver, they're terribly inadequate for the purpose of conveying information about the severity of changes introduced by an update (though I understand their appeal to mathematically-minded people). they're inadequate because they're implicit -- it's a bit like if someone decided they don't need hash maps because they can make do with arrays by remembering the order in which they're adding in the key-val pairs. if I remember the order, then I know which key the given index implicitly refers to, and the result is as good as a hash map, isn't it? except it isn't. keys are useful because they have explicit semantics , making it instantly clear what kind of value you're retrieving. in the same way, encoding the information about the severity of changes into version numbers makes it implicit (in addition to being ambiguous, as stated previously). why not use explicit keyword tags along with the version number (which can be romantic, semantic -- whichever floats the dev team's boat and best reflects the progress of the project) to give a heads up as to the nature of the update? e.g. :patch, :potentially-breaking, :major-api-change etc. granted, even language is a code which needs to be learned, like semver (gross oversimplification here, but let's not get into the details of language acquisition), but since it's widely established and conventionalized for conveying the kinds of meanings semver is trying to convey, why not just use it when it's available ? why use a system (version numbers) which is less well-suited to the purpose and ambiguous to boot? (on the other hand, numbers are eminently well-suited for keeping track of which version is newer than which and how much so -- the original purpose of version numbering -- because they are designed to have orderings defined on them. by contrast, words would do a terrible job at this. if you care to indicate the evolution of your codebase, you might introduce your own disciplined romantic or sentimental versioning scheme, which ironically is a more meaningful and ergo semantic way of doing versioning than semver, because it sticks to the conventional semantics of numbers (the closer the numbers, the more similar the versions). if you don't care about this, which is perfectly fine, you might as well use dates for version numbers.) keyword tags have the advantage that they're instantly human-readable by anyone who has a basic command of English. if there is sufficient will in the community, a useful subset can be frozen in a binding spec, so that they are machine-readable as well. I'm not sure whether these keywords should be an appendix to the version number (like v2.3.4-:potentially-breaking), or whether the information they provide should be more extensive and included in a formalized preamble to the changelog (finally forcing people to at least take a glance at it ;) ). using the latter approach, the information provided could be (optionally) even more targeted, e.g. detailing explicitly which parts of the API are affected in a non-backwards compatible manner by the update. anyways, just a few ideas :) I am not primarily a coder, so there may be obvious drawbacks to this scheme that I can't see or which have already been discussed by the community on multiple occasions which have escaped my attention. in which case, please bear with me and excuse my lack of sophistication.","url":"http://dlukes.github.io/output/beyond-semver.html","title":"Beyond semantic versioning? (cross-post)"},{"tags":"os x tips","text":"tl;dr Jump directly to the proposed solution . Tested on OS X 10.9 (Mavericks). Back story Airmail is a great application -- being very happy with Gmail's in-browser UI, it's honestly the first e-mail desktop client that I ever felt even remotely tempted to use. It has: a sleek, functional design almost flawless integration with Gmail (except for categories -- but there's a not-too-hackish way to deal with those) a Markdown compose mode (yay!) -- and tons of other good stuff. Especially that last feature almost got me sold -- you see, I like my e-mail hardwrapped (what Emacs calls \"filling paragraphs\"), because most of the time, I view it on monitors that are too wide for soft line wrapping to achieve a comfortable text width. (By the way, Airmail's layout deals with this issue very elegantly, but I know I won't be using only Airmail. Plus there are the obvious netiquette issues -- lines \"should be\" wrapped at 72 characters etc.) In Gmail, I therefore use plain-text compose, which is fine for the purposes described above, but frustrating whenever you want to apply formatting (obviously, you can't -- it's plain text). I tried using the usual replacements for formatting like stars & co., and I don't know about your grandma, but mine certainly doesn't take *...* to mean emphasis. I thought the Markdown compose mode in Airmail would solve my problems -- I could apply formatting if and when I wanted (using the frankly more streamlined process of typing it in rather than fumbling around for the right button in the GUI) and fill my paragraphs, because I somehow automatically assumed there'd by a hard-wrap feature like in any decent editor (read: emacs or vi). Markdown is plain text after all, isn't it? Long story short, as of yet, there isn't . There isn't even one for the plain-text compose mode, as far as I'm aware. So I added my two cents to this feature request thread and went back to the Gmail in-browser UI. Solution But then I realized (it took me a while, I'm still very much an OS X newbie): in OS X, you can define custom actions with shortcuts 1 for any application using Automator Services these actions can be easily set to receive text selected in the application as input these actions can also involve shell scripts there already is a great (command line) program for filling paragraphs -- it's called par , and as much as I admire what Airmail's developers have achieved, it's unlikely that they'd come up with a more sophisticated hard-wrapping algorithm than par 's simply as a side project for Airmail (see the EXAMPLES section in man par ) With that in mind, you can have hard-wrapping in Markdown or plain-text Airmail compose at your fingertips in no time flat. If you don't have homebrew , start by installing that (or any other ports manager that will allow you to install par ; I'll assume homebrew below) by pasting ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" at a Terminal prompt. Then: install par with brew install par at a Terminal prompt open Automator (e.g. by typing \"Automator\" into Spotlight) and create a new Service select the applications for which you want the service to be active (for me, that's just Airmail) and tick the \"Output replaces selected text\" box drag the \"Run Shell Script\" action onto the workflow canvas, and as the shell script, paste in PARINIT = \"rTbgqR B=.,?_A_a Q=_s>|\" /usr/local/bin/par 79 the $PARINIT environment variable contains the default recommended settings for par (if you want to customize its behavior, you can -- good luck wrapping your head around par 's manpage, though) you should set the full path to the par executable, the shell spawned by the Service might not inherit your $PATH -- for par installed via homebrew , it's /usr/local/bin/par the parameter at the end is the max number of characters per line -- mailing list etiquette stipulates 72, I personally prefer the pythonesque 79, but it's your choice At this point, your service should look something like in the screenshot below: Save it, open Keyboard preferences (type \"Keyboard\" into Spotlight), navigate to Shortcuts â†’ Services â†’ Text and set a keyboard shortcut for your newly created Service, e.g. Cmd+Opt+P. Next time you compose an e-mail in Airmail, just select the entire text when you're done (Cmd+A), press Cmd+Opt+P, and voilÃ ! Your lines have been hardwrapped, your paragraphs filled :) (Same thing, I know.) If the shortcut doesn't appear to work 1 , try fiddling around with it, resetting it (maybe the one you've chosen conflicts with a pre-existing one?), restarting Airmail, logging out and back in, rebooting... The custom shortcut part is unfortunately the least reliable aspect of this whole setup. Automator is a great idea, I was pleasantly surprised by it when I started using OS X a few days back, but it could seriously use some bug-squashing. If you fail miserably at getting the shortcut to work, you can still access your fill paragraph service via the menu (select the text you want to hard-wrap, then navigate to Airmail â†’ Services â†’ <name of your fill paragraph service>). Clicking around in a GUI is tedious (though hey -- it's the Apple way after all, isn't it?), but it shouldn't be too much of a bother since you need to do it only once per e-mail. Bottom line : I am now officially completely sold on Airmail (even bought the released version instead of using the free beta) and look forward to the joy of using it! EDIT: In order to have the least trouble possible getting the shell script up and running as a Service , two rules of thumb: Leave it completely up to OS X where it stores the Service (.workflow) file. This will probably be in ~/Library/Services , and I learnt the hard way not to tinker with it -- if Services is a symlink instead of a real directory, the OS won't discover new Service files (though old ones will still be accessible). If the Service doesn't show up in the keyboard shortcuts menu after creation, try refreshing the service list with /System/Library/CoreServices/pbs -update . Those shortcuts are in fact quite buggy, especially those that you want to be global (not specific to a concrete app) -- at least on Mavericks (OS X 10.9). They tend to get disabled on a whim, especially if you tinker with them, and are a pain to get working again (login, logout, reboot -- anything goes). If anyone knows why, please let me know! â†©","url":"http://dlukes.github.io/output/fill-par-in-airmail.html","title":"Filling (hardwrapping) paragraphs in Airmail with `par`"},{"tags":"os x tips","text":"Coming soon!","url":"http://dlukes.github.io/output/configuring-emacs-daemon-on-mac-os-x.html","title":"Configuring Emacs Daemon on Mac OS X"}]}